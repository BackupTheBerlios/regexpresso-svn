<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/1999/REC-html401-19991224/loose.dtd">
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
		<meta http-equiv="Content-Language" content="en">
		<meta name="author" content="cbonar@users.berlios.de">
		<meta name="date" content="20060405">
		<meta name="copyright" content="Placed in public domain by cbonar@users.berlios.de, 2005. Share and enjoy! See http://www.sourceforge.net/register/publicdomain.txt for more info on this license.">
		<meta name="robots" content="noindex,nofollow">
		<meta name="description" content="A quick tester for regular expressions">
		<meta name="keywords" content="regexpresso regex regexp regular expressions expression sidebar javavascript test tester evaluator">

		<title>RegExpresso</title>


		<!--
			Embedded, default, standalone style
		-->
		<style type="text/css">
			/* generic style */
			body { background-color:#EEEEEE; margin:0; padding:8px; font-family:arial,verdana; }
			div { margin-top:4px; margin-bottom:4px; }
			table { empty-cells:show; }
			/* the title */
			.title { font-family:arial,verdana,courier; font-size:13pt; font-weight:bold; }
			.presto { font-style:italic; color:red; }
			/* important messages */
			.error { color:red; }
			.warning { background-color:red; color:white; font-weight:bold; padding:2pt; }
			/* form fields */
			form { margin:0; }
			#subject, #output, .search { width:100%; }
			/*#output pre#match { overflow:scroll; }*/ /* scrolls the output zone when the text is too big ; if disabled it's the whole window that scrolls (better IMHO) */
			.button { width:auto; text-align:center; }
			/* generic style for a match */
			.match, .match_empty { border:solid red 1px; background-color:#FFFFE1; }
			/* backreference shown as a unique element */
			.backref, .backref_empty { border:solid gray 1px; background-color:#FFFFE1; }
			/* alternate appearance of the description fields */
			.desc_again { font-style:italic; }
			/* how to style a regular expression */
			.regex { background:#FFFFE1; font-weight:bold; padding-left:.2em; padding-right:.2em; border:dotted #000000 1px; }
			/* the menu */
			span.menu { position:fixed; top:-15px; left:0; }
			span.menu:hover, span.menu#hover { top:0; }
			img.menu { border:none; border-bottom:solid gray 1px; border-top:solid white 1px; }
			img.menu:hover, img.menu#hover { cursor:pointer; }
			/* documentation / external resources */
			a.doc { text-decoration:none; }
			/* text mode */
			.highlight { background-color:#DBFF00; border:dotted #999999 1px; }
			.highlight_empty { background-color:yellow; border:dotted #999999 1px; }
			/** Unfortunately (I'm starting to believe it's not due to misfortune),
				IE messes up the ".highlight>.highlight" CSS 2 notation,
				so we must use a separate class to render highlights inside highlights.
				Don't even think about having :before and :after working with IE, either. */
			.highlight_backref { background-color:white; border:none; border-left:dotted #999999 1px; }
			.highlight_backref:before, .highlight_backref:after { color:#999999; }
			.highlight_backref:before { content:"("; }
			.highlight_backref:after { content:")"; }
			.highlight_index { background:black; color:white; font-weight:bold; font-family:courier; border:none; }
			/* empty matches : for those browsers that just cannot guess the right font by themselves ; tested on WinXP only */
			.highlight_empty, .match_empty, .backref_empty { font-family:"Lucida sans Unicode"; font-size:xx-small; }
			.googlead { padding:0; margin:0; border:none; position:relative; left:-5px; }
			/* info div used to display context help */
			.info { font-weight:bold; color:blue; background:yellow; border:solid #808000 1px; padding:0; padding-left:2px; padding-right:2px; }
			.info a { text-decoration:none; }
			.info:hover { cursor:pointer; }
			/* input class highlights the tag as beeing an input zone */
			.input { border:solid #2449DB 1px; }												/* normal input style */
			.input:hover { border: solid orange 1px; }											/* on hover */
			input[type=text]:focus, textarea:focus { background-color:#FFFFBB; }		/* on focus for editable inputs */
			input[type=button], input[type=submit] { font-family:arial, verdana; font-size:9pt; }
			#options { font-size:small; background-color:#E1E1FF; }
			#options { display:none; }		/* options are initialy hidden */
			/* context is a concatenation of the following elements : info_text, text_before_match, match, text_after_match */
			.context_info {}
			.context_before, .context_after, .context_match { background-color:#BBBBBB; }
			.context_match { font-weight:bold; color:red; }
			/* same as input */
			.output { border: solid red 1px; border-collapse:collapse; background-color:white; }
			table.output thead tr th { background:red; color:white; font-weight:bold; font-size:90%; text-align:center; }
			.output tr.even { background:#DBFFBB; }
			.output tr:hover, .output tr:hover td * { background:#DBFF00; }		/* highlights the line under the cursor */
			/* table mode : column specific */
			.output thead tr > th:first-child { border-left:none; }			/* the left <th> must never show a different border */
			th.col_index {}
			th.col_match, th.col_groups, th.col_context { border-left:solid white 1px; }
			th.col_match, th.col_groups { text-align:left; }
			.tab_off, .tab_on { text-decoration:none; color:black; font-size:8pt; border-left:solid #a1a6a9 1px; border-right:solid #a1a6a9 1px; }
			.tab_off { background:#a1a6a9; }
			.tab_on { font-weight:bold; color:black; background:yellow; border-top:solid #a1a6a9 1px; border-bottom:solid #a1a6a9 1px; }
		</style>
		<!-- IE specific style -->
		<!--[if IE]>
			<style type="text/css">
				/* no support for 'position:fixed;' however 'absolute' is not far */
	     			span.menu { position:absolute; top:expression(document.body.scrollTop-15); }
	     			/* no ':hover' selector : the element under the cursor has its id changed to 'hover' by script */
				span.menu#hover { top:expression(document.body.scrollTop); }
	     		</style>
		<![endif]-->

		<script type="text/javascript"><!--
			google_ad_client = "pub-8221689042153078";
			google_alternate_color = "EEEEEE";
			google_ad_width = 234;
			google_ad_height = 60;
			google_ad_format = "234x60_as";
			google_ad_type = "text_image";
			google_ad_channel ="";
			google_color_border = "000000";
			google_color_bg = "FFFFFF";
			google_color_link = "0000FF";
			google_color_url = "008000";
			google_color_text = "000000";
		//--></script>


		<!--
			Compatibility section.
			Maybe should we check at the beginning of every function...
			I personally prefer not to restrict the user... after all he has been warned.
			However, this could become necessary if not all functions require the same compatibility level.
		-->
		<noscript type="text/javascript">
			<div class="warning">
			WARNING : Your browser does not support Javascript or it is disabled.
			You need it to be enabled to use this tool.
			</div>
		</noscript>
		<script type="text/javascript">
		<!--
			// indicates whether or not all tests were successfull
			var is_compatible = true;
			if ( ! window.RegExp )
			{
				is_compatible = false;
				document.write("\
					<div class='warning'>\
					WARNING : It seems that your browser does not support Javascript 1.5 regular expressions.\
					You won't be able to run this tool.\
					</div>\
					");
			}


			/**
				@returnval the version of IE
				@returnval 0 if not an IE browser
				@author http://support.microsoft.com/default.aspx?scid=kb;fr;468730
					First time ever I find accurate documentation on msdn :)
			*/
			function ie_version()
			{
				var ua = window.navigator.userAgent

				// Pour Internet Explorer, renvoie le numéro de version
				// Dans le cas d'un autre navigateur, renvoie 0
				var msie = ua.indexOf ( "MSIE " )
				if ( msie > 0 )
					return parseInt (ua.substring (msie+5, ua.indexOf (".", msie )));
				else
					return 0;
			}


			/**
				Adds a page to the Netscape sidebar.
				@author devedge.netscape.com (but wait... this author is dead ! :)
				@param sbTitle::String
					The default title of the panel
				@param sbLoc::String
					The URL of the page to load
			*/
			function netscape_addPanel(sbTitle,sbLoc)
			{
				// hack: bc 2002-01-04 work around http://bugzilla.mozilla.org/show_bug.cgi?id=99808
				// @todo : what if an error happens after the user called this method ? Is this handler registered globally or only inside this function ?
				window.onerror = function()
					{ alert("An error has occured during the sidebar installation. Please make sure your sidebar panel is open and then retry."); };

				if ((typeof window.sidebar == "object") && (typeof window.sidebar.addPanel == "function"))
					// this does not work if sbLoc is a local or relative URL. shit.
					window.sidebar.addPanel (sbTitle,sbLoc,"");
				else
					alert('This link is intended to work only with Netscape Gecko-based browsers such as Netscape 7.x.');
			}
		// -->
		</script>



		<!-- Generic functions, embedded in this script to make it "self-contained" -->
		<script type="text/javascript">
		<!--
			function myEscape( text )
			{
				return escape(text).replace(/\+/g,"%2B");
			}

			/**
				A simple iterator on an array, looping forever.
				@param values::Array
			*/
			function Loop( values )
			{
				this.index = 0;
				this.values = values;
				this.next = function() { return this.values[ (this.index++) % this.values.length ]; }
			}


			/**
				@return a TR as a DOM Node, containing a single cell
				@param cell
					The cell to add to this row
			*/
			function createSimpleRow( cell )
			{
				var tr = document.createElement("tr");
				tr.appendChild(cell);
				return tr;
			}



			/**
				@return a DOM Node and set some properties ; null parameters are ignored
				@param dom_type::String
					The type of the DOM Node
				@param css_class::String
					The CSS class
				@param dom_child::DOMElement
					The DOM Node to insert into the node
			*/
			function createSimpleElement( dom_type, css_class, dom_child )
			{
				//alert("createSimpleElement("+dom_type+","+text+","+css_class+")");

				var el = document.createElement(dom_type);
				if ( css_class != null )
					el.className = css_class;	// see DOM2 : this attribute has been renamed from 'class' to 'className' ; therefore, setAttribute is not reliable with Gecko browsers anymore
				if ( dom_child != null )
					el.appendChild(dom_child);
				return el;
			}



			/**
				@returnval the value of an argument of the URL
				@returnval null if not found or no regex support
				@returnval "" if the param was found but empty
				@param name
					the (case insensitive) name of the param
			*/
			function getParam( name )
			{
				if ( window.RegExp )
				{
					var result = new RegExp("[\\?&]"+name+"=([^&]*)&?","i").exec(window.location.search);
					if ( result != null && result[1] != null )
						// should work 100% with text/urlencoded only
						// with text/plain, the '+' signs will be converted to spaces, even if they were real '+'
						return unescape(result[1].replace(/\+/g," "));
					else
						return null;
				}
				else
					return null;
			}



			/**
				I haven't found better yet to get the logical value of a group of radio buttons.
			*/
			function getRadioButtonsValue( radioname )
			{
				//alert("getRadioButtonsValue("+radioname+")");
				var radios = document.getElementsByName(radioname);
				for ( var r=0 ; r<radios.length ; r++ )
				{
					if ( radios[r].checked )
					{
						//alert("getRadioButtonsValue("+radioname+")="+radios[r].value);
						return radios[r].value;
						}
				}
				//alert("getRadioButtonsValue("+radioname+")=undefineD");
				return undefined;
			}



		// -->
		</script>



		<!-- user stylesheet -->
		<script type="text/javascript">
		<!--
			var alt_style = getParam("stylesheet");
			if ( alt_style != null && alt_style != "" )
				document.write("<link rel='stylesheet' type='text/css' title='user style' href='"+alt_style+"'>");
		// -->
		</script>



		<!-- Functions specific to this tool -->
		<script type="text/javascript">
		<!--

			// temporary var used to remember what was the content of the regex field before keypress
			var buffer_regex;
			// last matches
			var matches = undefined;



			function showHideOptions()
			{
				dom_node = document.getElementById("options");
				dom_node.style.display = dom_node.style.display != "block" ? "block" : "none";
			}



			/* Manages the validity of the checked options (not all can be enabled at the same time) */
			function checkOption( option )
			{
				//alert("checkOption("+option+")");
				if ( document.getElementById("displaymode_text").checked )
				{
					document.form.autorefresh.disabled = false;
					document.form.showempty.disabled = false;
					document.form.showindex.disabled = false;
					document.form.backref.disabled = false;
					document.form.showcontext.disabled = true;
				}
				else if ( document.getElementById("displaymode_table").checked )
				{
					document.form.autorefresh.disabled = false;
					document.form.showempty.disabled = true;
					document.form.showindex.disabled = false;
					document.form.backref.disabled = false;
					document.form.showcontext.disabled = false;
				}
			}



			/* Manages the event for all options */
			function onOptionChange( option )
			{
				checkOption(option);
				// redraws the result
				document.form.submit.click();
				//document.style.col_index.display = form.showindex.disabled ? "none" : "inherit";
			}



			/**
				An email link with an error message, as a DOM anchor.

				@param text::String
					The text to be surrounded with the anchor
			*/
			function createReportLink( text )
			{
				var url = "mailto:cbonar@users.berlios.de";
				url += "?subject=" + myEscape("regexpresso error");
				url += "&body=regex=" + myEscape(document.form.regex);
				url += "%0D%0Asubject=" + myEscape(document.form.subject);
				url += "%0D%0Adisplaymode=" + getRadioButtonsValue("displaymode");
				url += "%0D%0Ainputmode=" + document.form.inputmode;
				url += "%0D%0Ashowempty=" + myEscape(document.form.showempty);
				url += "%0D%0Ashowindex=" + myEscape(document.form.showindex);
				url += "%0D%0Abackref=" + myEscape(document.form.backref);
				url += "%0D%0Ashowcontext=" + myEscape(document.form.showcontext);
				url += "%0D%0Aempty=" + myEscape(document.form.empty);
				url += "%0D%0Astylesheet=" + myEscape(document.form.stylesheet);
				url += "%0D%0Auser-agent=" + myEscape(navigator.userAgent);

				var anchor = createSimpleElement("a","error",document.createTextNode(text));
				anchor.setAttribute("href",url);

				return anchor;
			}



			function createReport( subject, user_entry )
			{
				var div = createSimpleElement("div","error",document.createTextNode("Unattended error. You can send a "));
				div.appendChild( createReportLink("mail report") );
				return div;
			}



			// once of two, we alternate the style in order to show something has been done
			// even if the result is exactly the same
			var desc_again = new Loop(["desc","desc_again"]);



			/**
				Parses the match and stores the results in a table of matches with each the following fields :
					before = what was not matched between the last match (or the start) and this match
					match = the matched text
					index = the index of the first char of the match
					groups = a table containing the matched groups
					context = formatted text showing the match in an extract of text
					after = the text that was not matched after
			*/
			function match( subject, regexp )
			{
				var matches = new Array();
				matches.tail = "";

				// computes the matches
				var results = regexp.exec(subject);

				// match_index is the index of the match of the original subject
				for ( m=0, match_index=0, text_before_index=0 ; results!=null && match_index<subject.length ; m++ )
				{
					matches[m] = new Object();

					// updates the index to the start of the match
					match_index += results.index;

					// saves the text not matched before this match
					matches[m].before = subject.substring(text_before_index,match_index);

					// saves the index
					matches[m].index = match_index;

					// saves the match
					matches[m].match = results[0];

					// saves the groups
					matches[m].groups = new Array();
					for ( r=1 ; r<results.length ; r++ )
						matches[m].groups[r-1] = ( results[r] == undefined ? "" : results[r] );	// this happens when the match is empty

					// prepares match_index for the next loop
					text_before_index = match_index + results[0].length;
					if ( results[0].length > 0 )
						match_index += results[0].length;
					else
						match_index++;
					results = regexp.exec( subject.substring(match_index,subject.length) );	// continue on the remaining part of the subject

					// saves the trailing text, if existing
					if ( results == null )
						matches.tail = subject.substring(match_index,subject.length);
				}

				return matches;
			}



			function formatContext( matches, index, subject, mode )
			{
				var match = matches[index].match;
				var match_index = matches[index].index
				var index_context_before = Math.max(0,match_index-10);
				var index_context_after = Math.min(match_index+match.length+10,subject.length);
				var context_before = subject.substring(index_context_before,match_index);		// what's before
				var context_after = subject.substring(Math.min(match_index+match.length,subject.length),index_context_after);	// what's after
				// the following "..." mark if there is text even before or after
				if ( index_context_before > 0 )
					context_before = "..." + context_before;
				if ( index_context_after < subject.length-1 )
					context_after += "...";

				switch ( mode )
				{
					// returns a result as a simple text node
					case "text":
						return document.createTextNode( "char. " + match_index + " : " + context_before + "*" + match + "*" + context_after );
					// returns the result as a styled span section
					default:
						var context = document.createElement("span");
						context.appendChild( createSimpleElement("span","context_info",document.createTextNode("char. "+match_index+" : ")) );
						context.appendChild( createSimpleElement("span","context_before",document.createTextNode(context_before)) );
						context.appendChild( createSimpleElement("span","context_match",document.createTextNode(match)) );
						context.appendChild( createSimpleElement("span","context_after",document.createTextNode(context_after)) );
						return context;
				}
			}



			/**
				Writes the results of a match in a table.

				@param output
					the DOMElement where to insert the results
				@param backref::Boolean
					if true, the matches captured by the parentheses will be shown
				@param empty::String
					the content to insert in empty matches
			*/
			function formatAsTable( output, matches, showempty, showindex, backref, showcontext, empty, subject, mode )
			{
				//alert("formatAsTable("+output+","+matches+","+showempty+","+showindex+","+backref+","+empty+")");

				// initiates the output container by inserting the head elements
				var dom_results = output.appendChild( createSimpleElement("table","output",null) );
				var thead = dom_results.appendChild( document.createElement("thead") );
				var table_header = thead.appendChild( document.createElement("tr") );
				if ( showindex )
					table_header.appendChild( createSimpleElement("th","col_index",document.createTextNode("N°")) );
				table_header.appendChild( createSimpleElement("th","col_match",document.createTextNode("MATCH")) );
				if ( backref )
					table_header.appendChild( createSimpleElement("th","col_groups",document.createTextNode("GROUPS")) );
				if ( showcontext )
					table_header.appendChild( createSimpleElement("th","col_context",document.createTextNode("CONTEXT")) );

				var tbody = dom_results.appendChild( document.createElement("tbody") );

				for ( m=0 ; m<matches.length ; m++ )
				{
					// inserts one line for each match
					var tr = tbody.appendChild( createSimpleElement("tr",m%2==0?"even":"odd",null) );

					// row 1 : index of the match
					if ( showindex )
					{
						var td_index = tr.appendChild( createSimpleElement("td","col_index",null) );
						td_index.appendChild( document.createTextNode(m) );
					}

					// row 2 : the raw match
					var td_match = tr.appendChild( createSimpleElement("td","col_match",null) );
					td_match_text = document.createTextNode(matches[m].match);
					td_match.appendChild( createSimpleElement( "span", "match", td_match_text ) );

					// row 3 : the groups
					if ( backref )
					{
						var td_groups = tr.appendChild( createSimpleElement("td","col_groups",null) );
						for ( g=0 ; g<matches[m].groups.length ; g++ )
						{
							td_groups_text = document.createTextNode(matches[m].groups[g]);
							td_groups_div = createSimpleElement( "span", "backref", td_groups_text );
							td_groups.appendChild( td_groups_div );
							td_groups.appendChild( document.createTextNode(" ") );
						}
					}

					// row 4 : context of the match (text before and after)
					if ( showcontext )
					{
						var td_context = tr.appendChild( createSimpleElement("td","col_context",null) );
						td_context.appendChild( formatContext( matches, m, subject, mode ) );
					}
				}
			}



			/**
				Writes the results of a match as plain text.
				I guess this would be clearer with a recursive algorithm...

				@param backref::Boolean
					if true, the matches captured by the parentheses will be shown
				@param empty::String
					the content to insert in empty matches
			*/
			function formatAsText( output, matches, showempty, showindex, backref, empty, subject, mode )
			{
				var dom_results = output.appendChild( createSimpleElement("pre","match",null) );

				for ( m=0 ; m<matches.length ; m++ )
				{
					// 1. text before
					dom_results.appendChild( createSimpleElement("span",null,document.createTextNode(matches[m].before)) );

					if ( matches[m].match.length > 0 )
					{
						// 2. index
						if ( showindex )
							dom_results.appendChild( createSimpleElement("span","highlight_index",document.createTextNode(m)) );

						// 3. text that matched
						var dom_highlight = createSimpleElement( "span", "highlight", document.createTextNode(matches[m].match) );
						dom_results.appendChild(dom_highlight);

						// 4. the remaining elements are the matches captured by the parentheses
						if ( backref && matches[m].groups.length>0 )
						{
							for ( g=0 ; g<matches[m].groups.length ; g++ )
								dom_highlight.appendChild( createSimpleElement("span","highlight_backref",document.createTextNode(matches[m].groups[g])) );
						}
					}
					// 2bis. empty symbol if matched but empty
					else if ( showempty )
					{
						// we show the empty cells by filling their content with the "empty set" symbol (here in UTF-8)
						// again, due to IE, we must declare a separate CSS class
						var dom_highlight = createSimpleElement( "span", "highlight_empty", null );
						dom_highlight.innerHTML = empty;
						dom_results.appendChild(dom_highlight);

						// TODO ? 3bis : empty groups ?
					}
				}

				// 5. don't forget the trailing text in text mode
				dom_results.appendChild( document.createTextNode(matches.tail) );
			}




			function replace( output, subject, regexp, replace_string, mode )
			{
				// computes the matches
				//alert(regexp+".replace("+subject+","+replace_string+")");
				var results = regexp.replace(subject,replace_string);

				var desc_class = desc_again.next();

				var info = createSimpleElement("div",desc_class,null);
				output.appendChild(info);

				// first, a message indicating whether the subject has been matched or not
				if ( results == null )
					info.innerHTML = "No match.";

				// then, creates the container for the results
				else if ( mode == "text" )
					var dom_results = output.appendChild( createSimpleElement("pre","match",null) );
				else
					var dom_results = output.appendChild( createSimpleElement("div","results",null) );

				// finally, iterate over the results and inserts them into the node
				// match_index is the index of the match of the original subject
				for ( howmany=1, match_index=0, text_before_index=0 ; results!=null && match_index<subject.length ; howmany++ )
				{
					// updates the index to the start of the match
					match_index += RegExp.index;

					info.innerHTML = howmany + (howmany>1 ? " matches :" : " match :");

					// the first element is the full match
					if ( mode == "text" )
					{
						var text_before = subject.substring(text_before_index,match_index);
						if ( text_before.length > 0 )
							dom_results.appendChild( document.createTextNode(text_before) );
						// var dom_highlight is used later to insert the backrefs into in text mode
						if ( results[0].length > 0 )
						{
							if ( showindex )
								dom_results.appendChild( createSimpleElement("span","highlight_index",document.createTextNode(howmany)) );
							var dom_highlight = createSimpleElement( "span", "highlight", document.createTextNode(results[0]) );
							dom_results.appendChild(dom_highlight);
						}
						else if ( showempty )
						{
							// we show the empty cells by filling their content with the "empty set" symbol (here in UTF-8)
							// again, due to IE, we must declare a separate CSS class
							var dom_highlight = createSimpleElement( "span", "highlight_empty", null );
							dom_highlight.innerHTML = empty;
							dom_results.appendChild(dom_highlight);
						}
					}
					else
					{
						dom_results.appendChild( createSimpleElement("div",desc_class,document.createTextNode("Matched at char. "+match_index+" :")) );

						var dom_match = createSimpleElement( "span", "match", document.createTextNode(results[0]) );
						// adds a tooltip describing the context
						// @todo visual tooltips are limited in length, if the match is too big, cut it
						var index_context_before = Math.max(0,match_index-10);
						var index_context_after = Math.min(match_index+results[0].length+10,subject.length);
						var context_before = subject.substring(index_context_before,match_index);		// what's before
						var context_after = subject.substring(Math.min(match_index+results[0].length,subject.length),index_context_after);	// what's after
						var tooltip = "char. " + match_index + " : ";
						if ( index_context_before > 0 )
							tooltip += "...";
						tooltip += context_before + "*" + results[0] + "*" + context_after;
						if ( index_context_after < subject.length-1 )
							tooltip += "...";
						dom_match.setAttribute("title",tooltip);

						dom_results.appendChild(dom_match);
					}

					// the remaining elements are the matches captured by the parentheses
					if ( backref && results.length>1 )
					{
						if ( mode != "text" )
							dom_results.appendChild( createSimpleElement("div",desc_class,document.createTextNode("Captured groups :")) );

						for ( r=1 ; r<results.length ; r++ )
						{
							//alert("match:["+results[r]+"]");
							var patched_result = ( results[r] == undefined ? "" : results[r] );	// this happens when the match is empty
							if ( mode == "text" )
								dom_highlight.appendChild( createSimpleElement("span","highlight_backref",document.createTextNode(patched_result)) );
							else
							{
								dom_results.appendChild( createSimpleElement("span","backref",document.createTextNode(patched_result)) );
								dom_results.appendChild( document.createElement("br") );
							}
						}
					}

					// prepares match_index for the next loop
					text_before_index = match_index + results[0].length;
					if ( results[0].length > 0 )
						match_index += results[0].length;
					else
						match_index++;
					results = regexp.exec( subject.substring(match_index,subject.length) );	// continue on the remaining part of the subject

					// don't forget the trailing text in text mode
					if ( mode == "text" && results == null )
					{
						var text_after = subject.substring(match_index,subject.length);
						if ( text_after.length > 0 )
							dom_results.appendChild(document.createTextNode(text_after));
					}
				}
			}



		/** Displays only the relevant input fields for the regex */
		function switchInputMode( mode )
		{
			document.getElementById("inputmode").value = mode;

			switch ( mode )
			{
				case "search":
					document.getElementById("regex_purejs").style.display = "none";
					document.getElementById("regex_search").style.display = "block";
					document.getElementById("regex_replace").style.display = "none";
					document.getElementById("regex_mod").style.display = "block";
					document.getElementById("tab_purejs").className = "tab_off";
					document.getElementById("tab_search").className = "tab_on";
					document.getElementById("tab_replace").className = "tab_off";
					break;
				case "replace":
					document.getElementById("regex_purejs").style.display = "none";
					document.getElementById("regex_search").style.display = "none";
					document.getElementById("regex_replace").style.display = "block";
					document.getElementById("regex_mod").style.display = "block";
					document.getElementById("tab_purejs").className = "tab_off";
					document.getElementById("tab_search").className = "tab_off";
					document.getElementById("tab_replace").className = "tab_on";
					break;
				default:
					document.getElementById("regex_purejs").style.display = "block";
					document.getElementById("regex_search").style.display = "none";
					document.getElementById("regex_replace").style.display = "none";
					document.getElementById("regex_mod").style.display = "none";
					document.getElementById("tab_purejs").className = "tab_on";
					document.getElementById("tab_search").className = "tab_off";
					document.getElementById("tab_replace").className = "tab_off";
					break;
			}

			// makes sure the regex' value is set according to the one currently displayed
			updateRegex();
		}



			/**
				Retrieve the URL's parameters if any to fill the form's fields with.
				That enables us for instance to deal with a full URL to show the result of a match.
				This is also used to open a new window with the same fields values as the current one.
			*/
			function parseURL()
			{
				var param_subject = getParam("subject");
				if ( param_subject != null )
					document.form.subject.value = param_subject;

				var param_regex = getParam("regex");
				if ( param_regex != null )
					document.form.regex.value = param_regex;

				var param_displaymode = getParam("displaymode");
				if ( param_displaymode != null )
				{
					document.getElementById("displaymode_"+param_displaymode).checked = true;
					checkOption(document.getElementById("displaymode_"+param_displaymode));
				}

				var param_inputmode = getParam("inputmode");
				if ( param_inputmode != null )
					switchInputMode(param_inputmode);

				var param_showempty = getParam("showempty");
				if ( param_showempty != null )
					document.form.showempty.checked = param_showempty == "on";
				checkOption(document.form.showempty);

				var param_showindex = getParam("showindex");
				if ( param_showindex != null )
					document.form.showindex.checked = param_showindex == "on";
				checkOption(document.form.showindex);

				var param_backref = getParam("backref");
				if ( param_backref != null )
					document.form.backref.checked = param_backref == "on";
				checkOption(document.form.backref);

				var param_showcontext = getParam("showcontext");
				if ( param_showcontext != null )
					document.form.showcontext.checked = param_showcontext == "on";
				checkOption(document.form.showcontext);

				var param_empty = getParam("empty");
				if ( param_empty != null )
					document.form.empty.value = param_empty;

				var param_stylesheet = getParam("stylesheet");
				if ( param_stylesheet != null )
					document.form.stylesheet.value = param_stylesheet;

				if ( param_subject != null && param_regex != null )
					go(param_subject,param_regex,"output");
			}



			/**
				@return a URL that represents this page with the current fields' values as parameters
				Remember : the checkboxes '.value' attribute does not reflect their state, but their initial value.
				The right attribute to monitor is '.checked'.
			*/
			function newLocation()
			{
				// the use of document.getElementById is necessary because the page could be located in a sidebar
				// and this property revealed to be the one of the main window (at least with Firefox).
				/// @todo is it really true, now that I have new clues ?
				if ( !!document.getElementById )
				{
					var param_subject = myEscape(document.getElementById('subject').value);
					var param_regex = myEscape(document.getElementById('regex').value);
					var param_displaymode = getRadioButtonsValue("displaymode");
					var param_inputmode = document.getElementById("inputmode").value;
					var param_showempty = document.getElementById('showempty').checked ? "on" : "";
					var param_showindex = document.getElementById('showindex').checked ? "on" : "";
					var param_backref = document.getElementById('backref').checked ? "on" : "";
					var param_showcontext = document.getElementById('showcontext').checked ? "on" : "";
					var param_empty = myEscape(document.getElementById("empty").value);
					var param_stylesheet = myEscape(document.getElementById("stylesheet").value);
					var url = document.location.pathname+'?subject='+param_subject+'&regex='+param_regex+'&displaymode='+param_displaymode+'&inputmode='+param_inputmode+'&showempty='+param_showempty+'&showindex='+param_showindex+'&backref='+param_backref+'&showcontext='+param_showcontext+"&empty="+param_empty+"&stylesheet="+param_stylesheet;
					//var url = document.location.href.replace(/\?(.*)/,"")+'?subject='+param_subject+'&regex='+param_regex+'&displaymode='+param_displaymode+'&showempty='+param_showempty+'&showindex='+param_showindex+'&backref='+param_backref+"&empty="+param_empty+"&stylesheet="+param_stylesheet;
				}
				/// @todo (maybe) else try with the standard document.form.subject, etc.
				else
					var url = document.location.href;

				// finally
				return url;
			}



			function prepare()
			{
				// locks the main input fields because it can take a while with long texts
				document.form.subject.disabled = true;
				document.form.regex.disabled = true;
			}



			/**
				@param subject
					The subject to which to apply the regular expression
				@param perl_regex
					The regex, Perl style
				@param output
					The unique ID of the HTML element where to write the output
			*/
			function go( subject, perl_regex, output )
			{
				//alert("go("+subject+","+perl_regex+","+dom_output_id+")");

				// every time a new result is displayed, the url to the new window is updated
				// this does not work well if local, but no problem if remote
				// Opera can't open local files with parameters
				var newloc = newLocation();
				document.getElementById("toMain").setAttribute("href",newloc);
				document.getElementById("toSidebar").setAttribute("href",newloc);

				// cleans the output zone by removing all its children
				var dom_output = document.getElementById(output);
				while ( dom_output.childNodes.length > 0 )
					dom_output.removeChild(dom_output.firstChild);

				// using Perl syntax
				var slashes = perl_regex.replace(/\\\\/g,"").replace(/\\\//,"").split("/").length-1;
				//alert(slashes+" slashes");
				// the user can omit the first slash
				if ( slashes == 1 && perl_regex.charAt(0) != "/" )
					perl_regex = "/" + perl_regex;
				// the user can enter no slash : he then gives only the subject to match
				else if ( slashes < 2 )
					perl_regex = "/" + perl_regex + "/";
				// we also allow the form : "s/search/replace" with no final slash
				else if ( new RegExp("s/.*/[^/]*","i").test(perl_regex) && slashes < 3 )
					perl_regex = perl_regex + "/";

				// prints the full regex
				var full_regex = dom_output.appendChild( createSimpleElement("span","regex",document.createTextNode(perl_regex)) );
				full_regex.setAttribute("title","The full regular expression");

				try
				{
					var action = perl_regex.match(/([ms]?)\//)[1];	// we can do that because we previously added (possibly) missing slashes
					switch( action )
					{
						case "s":
							var user_pattern = new RegExp("s/(.*)/(.*)/([^/]*)","i").exec(perl_regex);
							if ( user_pattern != null )
							{
								var pattern = user_pattern[1];
								var replace_string = user_pattern[2];
								var modifiers = user_pattern[3];

								//alert("s: new RegExp(\""+pattern+"\",\""+modifiers+"\")");
								var regex = new RegExp(pattern,modifiers);
								replace( dom_output, subject, regex, replace_string, getRadioButtonsValue("displaymode") );
							}
							else
								dom_output.appendChild( createReport() );
							break;

						case "m":
						case "":
							var user_pattern = new RegExp("m?/(.*)/([^/]*)","i").exec(perl_regex);
							if ( user_pattern != null )
							{
								var pattern = user_pattern[1];
								var modifiers = user_pattern[2];

								// computes the results
								//alert("m: new RegExp(\""+pattern+"\",\""+modifiers+"\")");
								var regex = new RegExp(pattern,modifiers);
								// using the global variable 'matches'
								matches = match( subject, regex );

								// display common informations
								var info = dom_output.appendChild( createSimpleElement("div",desc_again.next(),null) );
								if ( matches == null || matches.length == 0 )
									info.innerHTML = "No match.";
								else if ( matches.length == 1 )
									info.innerHTML = "1 match :";
								else
									info.innerHTML = matches.length + " matches :";

								// display according to the checked options
								if ( matches != null && matches.length > 0 )
								{
									switch( getRadioButtonsValue("displaymode") )
									{
										case "text":
											formatAsText( dom_output, matches, document.form.showempty.checked, document.form.showindex.checked, document.form.backref.checked, document.form.empty.value, subject, "text" );
											break;
										case "table":
											formatAsTable( dom_output, matches, document.form.showempty.checked, document.form.showindex.checked, document.form.backref.checked, document.form.showcontext.checked, document.form.empty.value, subject, "table" );
											break;
										default:
											// should never happen
											alert(getRadioButtonsValue("displaymode")+" : unknown display mode !");
											break;
									}
								}
							}
							else
								dom_output.appendChild( createReport() );
							break;
					}
				}
				catch ( e )
				{
					//alert("e.number=["+(e.number&0xFFFF)+"]\ne.message=["+e.message+"]\ne.description=["+e.description+"]");

					// @see http://msdn.microsoft.com/library/default.asp?url=/library/en-us/script56/html/js56jslrfJScriptErrorsTOC.asp
					if ( ie_version() > 0 )
					{
						switch ( e.number & 0xFFFF )
						{
							case 5017:	// Syntax error in regular expression
							case 5018:	// Unexpected quantifier
							case 5019:	// Expected ']' in regular expression
							case 5020:	// Expected ')' in regular expression
							case 5021:	// Invalid range in character set
								dom_output.appendChild( createSimpleElement("pre","error",document.createTextNode(e.description)) );
								break;
							default:
								throw e;
								break;
						}
					}
					else if ( e instanceof SyntaxError )
						dom_output.appendChild( createSimpleElement("pre","error",document.createTextNode(e.message)) );
					else
						throw e;
				}

				return false;
			}



		function finish()
		{
				// unlocks the input fields
				document.form.subject.disabled = false;
				document.form.regex.disabled = false;
		}



		function exportResult( matches )
		{
			var win = document.open("","_blank","width=320,height=240,menubar=1,scrollbars=1,resizable=1,toolbar=1");
			// finds the node to copy
			dom_output = document.getElementById('output');
			for ( m=0 ; m<matches.length ; m++ )
			{
				win.document.write(m+"\t"+matches[m].match+"\t"+matches[m].index);
				for ( g=0 ; g<matches[m].groups.length ; g++ )
					win.document.write("\t"+matches[m].groups[g]);
				win.document.writeln();
			}
			win.document.close();
			return false;
		}



		function updateRegex()
		{
			var regex = document.getElementById("regex");
			var oldval = regex.value;
			var modifiers = ( document.form.mod_I.checked ? '' : 'i' ) + ( document.form.mod_g.checked ? 'g' : '' ) + (document.form.mod_m.checked ? 'm' : '' );

			// 1. gets an active input field
			// 2. and updates the regex with its value
			switch( document.getElementById("inputmode").value )
			{
				case "search":
					regex.value = "/" + document.getElementById("regex_search_a").value + "/" + modifiers;
					break;

				case "replace":
					regex.value = "s/" + document.getElementById("regex_replace_a").value + "/" + document.getElementById("regex_replace_b").value + "/" + modifiers;
					break;

				default:
					regex.value = document.getElementById("regex_purejs_a").value;
					break;
			}

			// 3. updates the result if needed
			if ( document.form.autorefresh.checked && regex.value != oldval )
				document.form.submit.click();
		}


		// -->
		</script>
	</head>



	<body onLoad="javascript:parseURL();">
		<!--
			Top menu with links to open this page in different ways.

			This is a shame to be forced to add the boundary pictures in the HTML because of the non-CSS aware browsers, but I had no real choice :[
			More : IE just pops up the 'alt' attribute of the <img/> rather than the 'title' of <a/> (although it supports it).
			Well, now I think I'll have to consider using Javascript or another CSS method to display a popup menu... }:|

			The netscape_addPanel function does not work from the sidebar (at least with Firefox),
			but *hopefully* this does not make sense to use it from the sidebar.

			There are links to add this page to the sidebar of different browsers in the more convenient way I could afford.
			There is also a link that opens this page with the current fields values in a new window.
			Finally, there is a link that opens the results in the main (bigger) window, while in sidebar mode.
		-->
		<span class="menu" onMouseOver="this.id='hover'" onMouseOut="this.id=''" nowrap><!--
				Left (start) boundary
			--><img src="menu-down-left.png"><!--
				To the sidebar (only for IE and Firefox)
			--><a id="toSidebar" target="_search" href="regexpresso.html"><!--
				--><img class="menu" src="sidebar-22x22.png" alt="[sidebar]" title="Open result in sidebar (Internet Explorer and Firefox only)"><!--
			--></a><!--
				In a new window
			--><img class="menu" src="new-22x22.png" alt="[pop-out]" title="Open result in a new window" onMouseOver="this.id='hover'" onMouseOut="this.id=''" onClick="javascript:window.open(newLocation(),'_blank','width=240,height=640,scrollbars=yes,resizable=yes');"><!--
				Reopen in the current window
			--><a id="toMain" target="_main" href="regexpresso.html"><!--
				--><img class="menu" src="main-22x22.png" alt="[=&gt;]" title="Open result in the main window"><!--
			--></a><!--
				Export in a different format
			--><img class="menu" src="floppy-22x22.png" alt="[export]" title="Export the result" onMouseOver="this.id='hover'" onMouseOut="this.id=''" onClick="javascript:exportResult(matches);"><!--
				Import from the main window
			--><!--img class="menu" src="dropper-22x22.png" alt="[&lt=]" title="Import from the main window" onMouseOver="this.id='hover'" onMouseOut="this.id=''" onClick="javascript:document.form.subject.value='TODO';"--><!--
				Right (end) boundary
			--><img src="menu-down-right.png"><!--
		--></span>

		<!-- the tool's view -->

		<!-- title -->
		<div class="title">RegEx<span class="presto">presso</span></div>

		<!-- user's input -->
		<form name="form" id="form" onSubmit="javascript:prepare();go(this.subject.value,this.regex.value,'output');finish();return false;" enctype="UTF-8">
			<input type="hidden" id="empty" name="empty" value="&empty;">
			<input type="hidden" id="stylesheet" name="stylesheet" value="">
			<input type="hidden" id="inputmode" name="inputmode" value="purejs">
			<div><textarea name="subject" id="subject" class="input" rows="10" cols="20" onFocus="javascript:this.select();" title="The text ('subject') to evaluate">[Paste here the text to evaluate]</textarea></div>

			<!-- regex can be displayed using several modes -->
			<!-- 1. the real, hidden field -->
			<input type="hidden" name="regex" id="regex" value="/\b\w*(e)/i" style="width:100%; background:yellow;">
			<!-- tabs to change from one input mode to another -->
			<span><!--
			--><a href="" id="tab_search" class="tab_off" onclick="javascript:switchInputMode('search');return false;" title="Easy search mode">&nbsp;&nbsp;search&nbsp;&nbsp;</a><!--
			--><a href="" id="tab_replace" class="tab_off" onclick="javascript:switchInputMode('replace');return false;" title="Easy replace mode">&nbsp;&nbsp;replace&nbsp;&nbsp;</a><!--
			--><a id="tab_purejs" href="" class="tab_on" onclick="javascript:switchInputMode('purejs');return false;" title="Expert mode">&nbsp;&nbsp;expert&nbsp;&nbsp;</a><!--
		--></span>
			<div>
				<!-- 2. expert mode input field -->
				<div id="regex_purejs">
					<input type="text" id="regex_purejs_a" class="input search" value="/\b\w*(e)/i" title="'[m]/pattern/[modifiers]' or 's/pattern/replace/[modifiers]'"
						onFocus="javascript:this.select();"
						onkeyup="javascript:updateRegex();">
				</div>
				<!-- 3. 'easy' search mode, initially not displayed -->
				<div id="regex_search" style="display:none;">
					<input type="text" id="regex_search_a" class="input search" value="\b\w*(e)" title="Type your search expression here"
						onFocus="javascript:this.select();"
						onchange="javascript:updateRegex();"
						onkeyup="javascript:updateRegex();">
				</div>
				<!-- 4. 'easy' replace mode, initially not displayed -->
				<div id="regex_replace" style="display:none;">
					<input type="text" id="regex_replace_a" class="input" value="\b\w*(e)" title="Enter here the text you want to replace"
						onFocus="javascript:this.select();"
						onchange="javascript:updateRegex();"
						onkeyup="javascript:updateRegex();">
					<input type="text" id="regex_replace_b" class="input" value="[Replacement string]" title="Enter here the replacement string"
						onFocus="javascript:this.select();"
						onchange="javascript:updateRegex();"
						onkeyup="javascript:updateRegex();">
				</div>
				<!-- 5. modifiers, for 'easy' modes -->
				<div id="regex_mod" style="display:none;">
					<span style="white-space:nowrap;"><input id="mod_I" type="checkbox" onclick="javascript:updateRegex();" checked>case-sens.</span>
					<span style="white-space:nowrap;"><input id="mod_g" type="checkbox" onclick="javascript:updateRegex();">find all</span>
					<span style="white-space:nowrap;"><input id="mod_m" type="checkbox" onclick="javascript:updateRegex();">multiline</span>
				</div>
			</div>

			<div>
				<input name="submit" id="submit" type="submit" class="input" value="EVALUATE">
				<input type="button" id="options.caption" class="input" onclick="javascript:showHideOptions();" value="OPTIONS">
			</div>
			<div id="options" class="input">
				<table>
						<!-- NOTE : the onclick's below were added because of a behaviour observed in IE6 : the 'onchange' is not called after a 'onclick' => see what's the matter -->
						<tr title="Input change triggers evaluation">
							<td onClick="javascript:document.form.autorefresh.click();">Evaluate on the fly :</td>
							<td><input align="right" type="checkbox" id="autorefresh" name="autorefresh" onchange="onOptionChange(this);" onclick="onOptionChange(this);"></td>
							<td><label class="info" onclick="alert('AUTOREFRESH :\nCheck this box if you want the results to be updated whenever the regular expression or one of the option changes (not the text).');" onMouseOver="this.id='hover'" onMouseOut="this.id=''" >?</label></td>
						</tr>
						<tr title="Highlight matches inside the subject">
							<td onClick="javascript:document.getElementById('displaymode_text').click();">Display mode : <em>text</em></td>
							<td><input align="right" type="radio" id="displaymode_text" name="displaymode" value="text" title="Highlight matches inside the subject" onchange="onOptionChange(this);" onclick="onOptionChange(this);" checked></td>
							<td><label class="info" onclick="alert('HIGHLIGHT MODE :\nCheck this box to display the result with the same layout as in the parsed text and highlight matched parts.');return false;" onMouseOver="this.id='hover'" onMouseOut="this.id=''" >?</label></td>
						</tr>
						<tr title="Display results in a table">
							<td onClick="javascript:document.getElementById('displaymode_table').click();">Display mode : <em>table</em></td>
							<td><input align="right" type="radio" id="displaymode_table" name="displaymode" value="table" title="Display results in a table" onchange="onOptionChange(this);" onclick="onOptionChange(this);"></td>
							<td><label class="info" onclick="alert('TABLE MODE :\nCheck this box to display the results in a table.');return false;" onMouseOver="this.id='hover'" onMouseOut="this.id=''" >?</label></td>
						</tr>
						<tr title="Show or hide empty matches in the result">
							<td onClick="javascript:document.form.showempty.click();">Show empty matches :</td>
							<td><input align="right" type="checkbox" id="showempty" name="showempty" onchange="javascript:onOptionChange(this);" onclick="onOptionChange(this);" checked disabled></td>
							<td><label class="info" onclick="alert('EMPTY MATCHES :\nCheck this box if you want the empty matches (those of length 0) do be displayed as a special character.\nThe default character is the \'Null\' symbol.');" onMouseOver="this.id='hover'" onMouseOut="this.id=''" >?</label></td>
						<tr>
						<tr title="Show or hide the index for each match">
							<td onClick="javascript:document.form.showindex.click();">Show indexes :</td>
							<td><input align="right" type="checkbox" id="showindex" name="showindex" onchange="javascript:onOptionChange(this);" onclick="onOptionChange(this);" checked></td>
							<td><label class="info" onclick="alert('SHOW INDEXES :\nCheck this box if you want to identify every match by its index in the result field (the first one will be marked \'1\', etc.). Works in \'text\' mode only.');" onMouseOver="this.id='hover'" onMouseOut="this.id=''">?</label></td>
						<tr>
						<tr title="Show groups captured by the parentheses">
							<td onClick="javascript:document.form.backref.click();"><label>Show groups :</label></td>
							<td><input align="right" type="checkbox" id="backref" name="backref" onchange="javascript:onOptionChange(this);" onclick="onOptionChange(this);"></td>
							<td><label class="info" onclick="alert('SHOW GROUPS :\nCheck this box if you want to display the groups captured by the expression after every match. Groups are also known as \'back references\'. Works in \'text\' mode only.');" onMouseOver="this.id='hover'" onMouseOut="this.id=''" >?</label></td>
						<tr>
						<tr title="Show match in the original context (text before and after)">
							<td onClick="javascript:document.form.showcontext.click();"><label>Show context :</label></td>
							<td><input align="right" type="checkbox" id="showcontext" name="showcontext" onchange="javascript:onOptionChange(this);" onclick="onOptionChange(this);" checked disabled></td>
							<td><label class="info" onclick="alert('SHOW CONTEXT :\nExplain here. Works in \'table\' mode only.');" onMouseOver="this.id='hover'" onMouseOut="this.id=''" >?</label></td>
						<tr>
				</table>
			</div>
		</form>

		<!-- script's output (dynamic content) -->
		<span id="output">
		</span>

		<!-- Some external resources -->
		<hr>
		<div id="doc" title="External resources">
			<!-- note : the following target : "_main" works well for IE (from which it comes), Mozilla and Firefox ; Opera opens a new tab -->
			[<a class="doc" target="_main" href="http://www.regular-expressions.info/javascript.html">Introduction to regular expressions</a>]<br>
			[<a class="doc" target="_main" href="http://www.webreference.com/js/column5/index.html">A comprehensive article</a>]<br>
			[<a class="doc" target="_main" href="http://regexpresso.berlios.de/readme.html">About this tool</a>]<br>
			<br>
			<a align="right" target="_main" href="http://developer.berlios.de"><img src="http://developer.berlios.de/bslogo.php?group_id=3235&type=1" width="124" height="32" border="0" alt="[BerliOS Logo]"></a><br>
			<br>
			<div class="googlead"><script type="text/javascript" src="http://pagead2.googlesyndication.com/pagead/show_ads.js"></script></div>
		</div>
</body>

</html>